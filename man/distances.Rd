% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spread-process.R
\name{distanceFromEachPoint}
\alias{.pointDistance}
\alias{distanceFromEachPoint}
\alias{pointDistance}
\title{Calculate distances between many points and many grid cells}
\usage{
distanceFromEachPoint(from, to = NULL, landscape, asymmetry = NA_real_,
  maxDistance = NA_real_)

.pointDistance(a, b, asymmetry = NA_real_, maxDistance = NA_real_)
}
\arguments{
\item{from}{matrix with 2 or 3 columns, x and y, representing x and y coordinates of "from" cell,
and optional "id" which will be matched with "id" from \code{to}}

\item{to}{matrix with 2  or 3 columns (or optionally more, all of which will be returned),
x and y, representing x and y coordinates of "to" cells, and
optional "id" which will be matched with "id" from \code{from}}

\item{landscape}{RasterLayer. optional. This is only used if \code{to} is NULL, in which case
all cells are considered \code{to}}

\item{asymmetry}{A numeric indicating the ratio of the asymmetry to be used. Default is
NA, indicating no asymmetry. See details. This is still experimental.
Use with caution.}

\item{maxDistance}{Numeric in units of number of cells. The algorithm will build the whole surface
(from \code{from} to \code{to}), but will remove all distances that are above
this distance.}

\item{a}{matrix with 2 columns, x and y, representing x and y coordinates of "to" cells}

\item{b}{matrix with 1 row and 2 columns, x and y, representing x and y coordinates of "from" cell}
}
\value{
A sorted matrix on \code{id} with same number of rows as \code{to},
        but with one extra column, \code{"dists"}
        indicating the distance between from and to.
}
\description{
This is a modification of \code{\link[raster]{distanceFromPoints}} for the case of many points.
This version can often be faster for a single point because it does not return a RasterLayer. This is
different than \code{\link[raster]{distanceFromPoints}} because it does not take the minimum
distance from the set of points to all cells. Rather this returns the every pair-wise point distance.
As a result, this can be used for doing inverse distance weightings, seed rain, cumulative effects
of distance-based processes etc. If memory limitation is an issue, maxDistance will keep memory
use down, but with the consequences that there will be a maximum distance returned. This function
has the potential to use a lot of memory if there are a lot of \code{from} and \code{to} points.
}
\details{
\code{distanceFromEachPoint} calls \code{.pointDistance}, which is not intended to be called
directly by the user.

This function has been tested and is fast with 100 \code{from} points and 1e6 \code{to} points.
}
\examples{
library(raster)
N <- 2
distRas <- raster(extent(0,40,0,40), res = 1)
coords <- cbind(x = round(runif(N, xmin(distRas), xmax(distRas)))+0.5,
                y = round(runif(N, xmin(distRas), xmax(distRas)))+0.5)

# inverse distance weights
dists1 <- distanceFromEachPoint(coords, landscape = distRas)
indices <- cellFromXY(distRas,dists1[,c("x","y")])
invDist <- tapply(dists1[,"dists"], indices, function(x) sum(1/(1+x))) # idw function
distRas[] <- as.vector(invDist)
if(interactive()) Plot(distRas, new=TRUE)
}
\seealso{
\code{\link{rings}}, \code{\link{cir}}, \code{\link[raster]{distanceFromPoints}}, which can
all be made to do the same thing, under specific combinations of arguments. But each has different
primary use cases.
}

