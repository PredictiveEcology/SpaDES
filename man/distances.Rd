% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spread-process.R
\name{distanceFromEachPoint}
\alias{.pointDistance}
\alias{distanceFromEachPoint}
\alias{pointDistance}
\title{Calculate distances between many points and many grid cells}
\usage{
distanceFromEachPoint(from, to = NULL, landscape, asymmetry = NA_real_)

.pointDistance(a, b, asymmetry = NA_real_)
}
\arguments{
\item{from}{matrix with 2 or 3 columns, x and y, representing x and y coordinates of "from" cell, and
optional "id" which will be matched with "id" from \code{to}}

\item{to}{matrix with 2  or 3 columns (or optionally more, all of which will be returned),
x and y, representing x and y coordinates of "to" cells, and
optional "id" which will be matched with "id" from \code{from}}

\item{landscape}{RasterLayer. optional. This is only used if \code{to} is NULL, in which case
all cells are considered \code{to}}

\item{asymmetry}{A numeric indicating the ratio of the asymmetry to be used. Default is
NA, indicating no asymmetry. See details. This is still experimental.
Use with caution.}

\item{a}{matrix with 2 columns, x and y, representing x and y coordinates of "to" cells}

\item{b}{matrix with 1 row and 2 columns, x and y, representing x and y coordinates of "from" cell}
}
\value{
A sorted matrix on \code{id} with same number of rows as \code{to},
        but with one extra column, \code{"dists"}
        indicating the distance between from and to.
}
\description{
This is a modification of \code{\link[raster]{distanceFromPoint}} for the case of many points.
This is faster for a single point because it does not return a RasterLayer. This is
different than \code{\link[raster]{distanceFromPoint}} because it does not take the minimum
distance from the set of points to all cells. Rather this returns the every pair-wise point distance.
As a result, this can be used for doing Because this
}
\examples{
library(raster)
N <- 2
distRas <- raster(extent(0,40,0,40), res = 1)
coords <- cbind(x = round(stats::runif(N, xmin(distRas), xmax(distRas)))+0.5,
                                        y = round(stats::runif(N, xmin(distRas), xmax(distRas)))+0.5)

# inverse distance weights
dists1 <- distanceFromEachPoint(coords, landscape = distRas)
indices <- cellFromXY(distRas,dists1[,c("x","y")])
invDist <- tapply(dists1[,"dists"], indices, function(x) sum(1/(1+x))) # idw function
distRas[] <- as.vector(invDist)
if(interactive()) Plot(distRas, new=TRUE)
}

