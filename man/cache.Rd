% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache.R
\docType{methods}
\name{Cache}
\alias{Cache}
\alias{Cache,ANY-method}
\alias{cache}
\alias{cache,ANY-method}
\alias{clearCache}
\alias{clearCache,ANY-method}
\alias{showCache}
\alias{showCache,ANY-method}
\title{Cache method that accomodates environments, S4 methods, Rasters}
\usage{
Cache(FUN, ..., notOlderThan = NULL, objects = NULL, outputObjects = NULL,
  algo = "xxhash32", cacheRepo = NULL)

\S4method{Cache}{ANY}(FUN, ..., notOlderThan = NULL, objects = NULL,
  outputObjects = NULL, algo = "xxhash32", cacheRepo = NULL)

clearCache(sim, afterDate, beforeDate, cacheRepo, ...)

\S4method{clearCache}{ANY}(sim, afterDate, beforeDate, cacheRepo, ...)

showCache(sim, cacheRepo, ...)

\S4method{showCache}{ANY}(sim, cacheRepo, ...)

cache(cacheRepo = NULL, FUN, ..., notOlderThan = NULL, objects = NULL,
  outputObjects = NULL, algo = "xxhash32")

\S4method{cache}{ANY}(cacheRepo = NULL, FUN, ..., notOlderThan = NULL,
  objects = NULL, outputObjects = NULL, algo = "xxhash32")
}
\arguments{
\item{FUN}{A function to be called.}

\item{...}{Other arguments passed to

If neither \code{afterDate} or \code{beforeDate} are provided, then all objects will be removed.
If both \code{afterDate} and \code{beforeDate} are specified, then all objects between \code{afterDate} and
\code{beforeDate} will be deleted.}

\item{notOlderThan}{load an artifact from the database only if it was created after notOlderThan.}

\item{objects}{Character vector of objects within the simList that should
be considered for caching. i.e., only use a subset of
the simList objects. Only used if ... includes a \code{simList}.}

\item{outputObjects}{Optional character vector indicating which objects to
return. This is only relevant for \code{simList} objects}

\item{algo}{The algorithms to be used; currently available choices are
    \code{md5}, which is also the default, \code{sha1}, \code{crc32},
    \code{sha256}, \code{sha512}, \code{xxhash32}, \code{xxhash64} and
    \code{murmur32}.}

\item{cacheRepo}{A repository used for storing cached objects. This is optional
if \code{Cache} is used inside a SpaDES module.}

\item{sim}{A \code{simList} simulation object, generally produced by \code{simInit}.}

\item{afterDate}{Objects cached after this date will be deleted, formatted YYYY-MM-DD.}

\item{beforeDate}{Objects cached before this date will be deleted, formatted as YYYY-MM-DD.}
}
\value{
As with \code{\link[archivist]{cache}}, the return is either the return
value of the function call or the cached version (i.e., the result from a previous
call to this same cached function with identical arguments).

Will clear all objects from the \code{cachePath} of the sim object
}
\description{
This function is largely copied from \code{\link[archivist]{cache}}, with
three very critical modifications.  The archivist package detects
different environments as different. It also does not detect S4 methods
correctly due to method inheritance. Finally, it does not detect
objects that have file-base storage of information
(like \code{\link[raster]{RasterLayer-class}} objects and
\code{\link[ff]{ff}} objects). This version of the \code{cache} function
accomodates those 3 special, though quite common, cases by 1) converting
the any environments into list equivalents, 2) identifying the dispatched
S4 method (including those made through inheritance) before
\code{\link[digest]{digest}} is called so the correct method is being
cached, and 3) by running \code{\link[digest]{digest}} on the linked
file.

\code{showCache} and \code{clearCache} are wrappers around \code{archivist} package
functions, specific to simList objects.
They allow the user a bit of control over what is being cached.
}
\details{
Because the \code{simList} has an environment as one of its slots,
the caching mechanism of the archivist package does not work on
simLists nor any functions or objects defined inside a module.

Some of the details of the changes include:
We remove all elements that have an environment as part of
their attributes.
This is generally functions that are loaded from the modules,
but also the \code{.envir} slot in the \code{simList}.
Functions are formatted to text before running digest.

Cache (capital C) is a short cut to using SpaDES::cache as it
can be called from inside a SpaDES module without
specifying the \code{cacheRepo}. SpaDES will use the cacheRepo from a call
to \code{cachePath(sim)}, taking the sim from the call stack. Cache
(capital C) is also defined so that it is not confused with the
archivist::cache function which will not work in a SpaDES context. If
a user would like to use \code{cache} (lower case C), then it must be
always prefixed with \code{SpaDES::cache(  )} so that it does not accidentally
call the achivist package version of cache.
}
\note{
In general, it is expected that caching will only be used when stochasticity
is not relevant, or if a user has achieved sufficient stochasticity (e.g., via
sufficient number of calls to \code{experiment}) such that no new explorations
of stochastic outcomes are required.
}
\section{Caching as part of SpaDES}{


SpaDES has several levels of caching. Each level can be used to a modelers
advantage; and, each can be used simultaneously.
}

\section{\code{spades} or \code{experiment}}{


And entire call
to \code{spades} or \code{experiment} can be cached. This will have the effect
of eliminating any stochasticity in the model as the output will simply be
the cached version of the \code{simList}.
}

\section{Module-level caching}{


Is the parameter \code{.useCache} is set to TRUE, then the \code{doEvent.moduleName}
will be cached. That means taht every time that module
is called from within a spades or experiment call, cache will be used. Only
the objects inside the \code{simList} that correspond to the inputObjects of the
module and the outputObjects to the module will be assessed for caching
inputs or output, respectively.

In general use, module level caching would be mostly useful for modules that have
no stochasticity, such as data-preparation modules, GIS modules etc.
}

\section{Function-level caching}{


Any function can be cached using:
\code{Cache(FUN = functionName, ...)}
or
\code{cache(cacheRepo = cacheDirectory, FUN = functionName, ...)}. This will
be a slight change to a function call, such as:
\code{projectRaster(raster, crs = crs(newRaster))}
to
\code{Cache(projectRaster, raster, crs = crs(newRaster))}
}
\examples{
\dontrun{
mySim <- simInit(times=list(start=0.0, end=5.0),
                 params=list(.globals=list(stackName="landscape", burnStats = "testStats")),
                 modules=list("randomLandscapes", "fireSpread"),
                 paths=list(modulePath=system.file("sampleModules", package="SpaDES")))

  # This functionality can be achieved within a spades call
  # compare caching ... run once to create cache
  system.time(outSim <- spades(copy(mySim), cache = TRUE, notOlderThan = Sys.time(),
                               .plotInitialTime = NA))
  # compare... second time is fast
  system.time(outSimCached <- spades(copy(mySim), cache = TRUE, .plotInitialTime = NA))
  all.equal(outSim, outSimCached)

  # Function caching
  ras <- raster(extent(0,1e3,0,1e3),res = 1)
  system.time(map <- Cache(gaussMap, ras, cacheRepo = cachePath(mySim),
                           notOlderThan = Sys.time()))
  # second time much faster
  system.time(mapCached <- Cache(gaussMap, ras, cacheRepo = cachePath(mySim)))

  # They are the same
  all.equal(map, mapCached)

  # Module-level
  # In this example, we will use the cache on the randomLandscapes module
  # This means that each subsequent call to spades will result in identical
  # outputs from the randomLandscapes module (only!).
  # This would be useful when only one random landscape is needed
  # simply for trying something out, or putting into production code
  # (e.g., publication, decision support, etc.)
  params(mySim)$randomLandscapes$.useCache <- TRUE
  system.time(randomSim <- spades(SpaDES::copy(mySim), .plotInitialTime = NA,
                                 notOlderThan = Sys.time(), debug = TRUE))

  # user  system elapsed
  # 1.26    0.25    7.00
  # Vastly faster
  system.time(randomSimCached <- spades(SpaDES::copy(mySim), .plotInitialTime = NA,
                                 debug = TRUE))
   # user  system elapsed
   # 0.22    0.00    0.24
   # Test that only layers produced in randomLandscapes are identical, not fireSpread
   layers <- list("DEM","forestAge", "habitatQuality", "percentPine","Fires")
   same <- lapply(layers, function(l) identical(randomSim$landscape[[l]],
                                        randomSimCached$landscape[[l]]))
   names(same) <- layers
   print(same)

}

\dontrun{
clearCache(mySim)
}
\dontrun{
showCache(mySim)
}
}
\author{
Eliot McIntire
}
\seealso{
\code{\link[archivist]{cache}}.

\code{\link[archivist]{splitTagsLocal}}.
}

