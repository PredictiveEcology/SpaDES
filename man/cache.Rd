% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cache.R
\docType{methods}
\name{Cache}
\alias{Cache}
\alias{Cache,ANY-method}
\alias{clearCache}
\alias{clearCache,ANY-method}
\alias{showCache}
\alias{showCache,ANY-method}
\alias{cache}
\alias{cache,ANY-method}
\title{Cache method that accomodates environments, S4 methods, Rasters}
\usage{
Cache(FUN, ..., notOlderThan = NULL, objects = NULL, outputObjects = NULL,
  algo = "xxhash32", cacheRepo = NULL, compareRasterFileLength = 1e+06,
  sideEffect = FALSE, makeCopy = FALSE, quick = FALSE)

\S4method{Cache}{ANY}(FUN, ..., notOlderThan = NULL, objects = NULL,
  outputObjects = NULL, algo = "xxhash32", cacheRepo = NULL,
  compareRasterFileLength = 1e+06, sideEffect = FALSE, makeCopy = FALSE,
  quick = FALSE)

clearCache(sim, afterDate, beforeDate, cacheRepo, ...)

\S4method{clearCache}{ANY}(sim, afterDate, beforeDate, cacheRepo, ...)

showCache(sim, cacheRepo, ...)

\S4method{showCache}{ANY}(sim, cacheRepo, ...)

cache(cacheRepo = NULL, FUN, ..., notOlderThan = NULL, objects = NULL,
  outputObjects = NULL, algo = "xxhash32")

\S4method{cache}{ANY}(cacheRepo = NULL, FUN, ..., notOlderThan = NULL,
  objects = NULL, outputObjects = NULL, algo = "xxhash32")
}
\arguments{
\item{FUN}{A function to be called.}

\item{...}{Other arguments passed to

If neither \code{afterDate} or \code{beforeDate} are provided, then all objects will be removed.
If both \code{afterDate} and \code{beforeDate} are specified, then all objects between \code{afterDate} and
\code{beforeDate} will be deleted.}

\item{notOlderThan}{load an artifact from the database only if it was created after notOlderThan.}

\item{objects}{Character vector of objects within the simList that should
be considered for caching. i.e., only use a subset of
the simList objects. Only used if ... includes a \code{simList}.}

\item{outputObjects}{Optional character vector indicating which objects to
return. This is only relevant for \code{simList} objects}

\item{algo}{The algorithms to be used; currently available choices are
    \code{md5}, which is also the default, \code{sha1}, \code{crc32},
    \code{sha256}, \code{sha512}, \code{xxhash32}, \code{xxhash64} and
    \code{murmur32}.}

\item{cacheRepo}{A repository used for storing cached objects.
This is optional if \code{Cache} is used inside a SpaDES module.}

\item{compareRasterFileLength}{Numeric. Optional. When there are Rasters, that
have file-backed storage, this is passed to the length arg in \code{digest}
when determining if the Raster file is already in the database.
Default 1e6. Passed to \code{prepareFileBackedRaster}.}

\item{sideEffect}{A logical argument. Only effective when cache operates on dwdData.If TRUE,the argument check if files to be downloaded
are found locally prior to download. When the files are absent, they are recovered from a copy (the argument
makeCopy must have been set as TRUE the first time chache was runned).}

\item{makeCopy}{A logical argument. Only effective when cache operates on dwdData. It creates a copy of the downloaded
files in the cacheRepo/gallery directory to optimize recovering. Only work when cache run for the first time for now.}

\item{quick}{A logical argument. If TRUE, checksum is compiled using the combination of the filename and its size.
If FALSE, cheksum is compiled using the object. Default is FALSE.}

\item{sim}{A \code{simList} simulation object, generally produced by \code{simInit}.}

\item{afterDate}{Objects cached after this date will be deleted, formatted YYYY-MM-DD.}

\item{beforeDate}{Objects cached before this date will be deleted, formatted as YYYY-MM-DD.}
}
\value{
As with \code{\link[archivist]{cache}}, the return is either the return
value of the function call or the cached version (i.e., the result from a previous
call to this same cached function with identical arguments).

Will clear all objects from the \code{cachePath} of the sim object
}
\description{
This function is largely copied from \code{\link[archivist]{cache}}, with
three very critical modifications:
1) the \code{archivist} package detects different environments as different;
2) it also does not detect S4 methods correctly due to method inheritance;
3) it does not detect objects that have file-base storage of information
(like \code{\link[raster]{RasterLayer-class}} objects and
\code{\link[ff]{ff}} objects).
This version of the \code{cache} function accomodates those three special,
though quite common, cases by:
1) converting any environments into list equivalents;
2) identifying the dispatched S4 method (including those made through
inheritance) before \code{\link[digest]{digest}} is called so the correct
method is being cached;
and 3) by running \code{\link[digest]{digest}} on the linked file.
In the \code{SpaDES} context, the \code{simList} has an environment as one of
its slots, thus using \code{archivist::cache} will not work correctly.

\code{showCache} and \code{clearCache} are wrappers around \code{archivist} package
functions, specific to simList objects.
They allow the user a bit of control over what is being cached.
}
\details{
Some of the details of the changes include:
We remove all elements that have an environment as part of their attributes.
This is generally functions that are loaded from the modules,
but also the \code{.envir} slot in the \code{simList}.
Functions are formatted to text before running digest.

Cache (capital C) is a short cut to using SpaDES::cache as it
can be called from inside a SpaDES module without
specifying the \code{cacheRepo}. SpaDES will use the cacheRepo from a call
to \code{cachePath(sim)}, taking the sim from the call stack. Similarly, if no
\code{cacheRepo} is specified, then it will use \code{getPaths()$cachePath}, which
will, by default, be a temporary location with no persistence between R sessions!
To persist between sessions, use \code{SpaDES::setPaths()} every session.

\code{Cache} (uppercase C) is also defined so that it is not confused with the
\code{archivist::cache} function which will not work in a SpaDES context.
If a user would like to use \code{cache} (lowercase c), then it must be
always prefixed with \code{SpaDES::cache(  )} so that it does not accidentally
call the achivist package version of cache.
}
\note{
In general, it is expected that caching will only be used when stochasticity
is not relevant, or if a user has achieved sufficient stochasticity (e.g., via
sufficient number of calls to \code{experiment}) such that no new explorations
of stochastic outcomes are required. It will also be very useful in a
reproducible work flow
}
\section{Caching as part of SpaDES}{


SpaDES has several levels of caching. Each level can be used to a modelers
advantage; and, each can be used simultaneously.
}

\section{\code{spades} or \code{experiment}}{


And entire call
to \code{spades} or \code{experiment} can be cached. This will have the effect
of eliminating any stochasticity in the model as the output will simply be
the cached version of the \code{simList}.
}

\section{Module-level caching}{


If the parameter \code{.useCache} is set to TRUE, then the \code{doEvent.moduleName}
will be cached. That means that every time that module
is called from within a spades or experiment call, cache will be used. Only
the objects inside the \code{simList} that correspond to the inputObjects of the
module and the outputObjects to the module will be assessed for caching
inputs or output, respectively.

In general use, module level caching would be mostly useful for modules that have
no stochasticity, such as data-preparation modules, GIS modules etc.
}

\section{Event-level caching}{


If the parameter \code{.useCache} is set to a character or character vector,
then that or those event(s) will be cached. That means that every time the event
is called from within a spades or experiment call, cache will be used. Only
the objects inside the \code{simList} that correspond to the inputObjects of the
module and the outputObjects to the module will be assessed for caching
inputs or output, respectively. The fact that all and only the named inputObjects
and outputObjects are cached and returned may be inefficient (i.e., it may
cache more objects than are necessary) for individual events.

In general use, event-level caching would be mostly useful for events that have
no stochasticity, such as data-preparation events, GIS events etc.
}

\section{Function-level caching}{


Any function can be cached using:
\code{Cache(FUN = functionName, ...)}
or
\code{cache(cacheRepo = cacheDirectory, FUN = functionName, ...)}. This will
be a slight change to a function call, such as:
\code{projectRaster(raster, crs = crs(newRaster))}
to
\code{Cache(projectRaster, raster, crs = crs(newRaster))}
}

\examples{
\dontrun{
mySim <- simInit(times = list(start = 0.0, end = 5.0),
                 params = list(.globals = list(stackName = "landscape", burnStats = "testStats")),
                 modules = list("randomLandscapes", "fireSpread"),
                 paths = list(modulePath = system.file("sampleModules", package = "SpaDES")))

  # This functionality can be achieved within a spades call
  # compare caching ... run once to create cache
  system.time(outSim <- spades(Copy(mySim), cache = TRUE, notOlderThan = Sys.time(),
                               .plotInitialTime = NA))
  # compare... second time is fast
  system.time(outSimCached <- spades(Copy(mySim), cache = TRUE, .plotInitialTime = NA))
  all.equal(outSim, outSimCached)

  # Function caching
  ras <- raster(extent(0,1e3,0,1e3),res = 1)
  system.time(map <- Cache(gaussMap, ras, cacheRepo = cachePath(mySim),
                           notOlderThan = Sys.time()))
  # second time much faster
  system.time(mapCached <- Cache(gaussMap, ras, cacheRepo = cachePath(mySim)))

  # They are the same
  all.equal(map, mapCached)

  # Module-level
  # In this example, we will use the cache on the randomLandscapes module
  # This means that each subsequent call to spades will result in identical
  # outputs from the randomLandscapes module (only!).
  # This would be useful when only one random landscape is needed
  # simply for trying something out, or putting into production code
  # (e.g., publication, decision support, etc.)
  params(mySim)$randomLandscapes$.useCache <- TRUE
  system.time(randomSim <- spades(Copy(mySim), .plotInitialTime = NA,
                                 notOlderThan = Sys.time(), debug = TRUE))

  # user  system elapsed
  # 1.26    0.25    7.00
  # Vastly faster
  system.time(randomSimCached <- spades(Copy(mySim), .plotInitialTime = NA,
                                 debug = TRUE))
   # user  system elapsed
   # 0.22    0.00    0.24
   # Test that only layers produced in randomLandscapes are identical, not fireSpread
   layers <- list("DEM","forestAge", "habitatQuality", "percentPine","Fires")
   same <- lapply(layers, function(l) identical(randomSim$landscape[[l]],
                                        randomSimCached$landscape[[l]]))
   names(same) <- layers
   print(same)

}

\dontrun{
clearCache(mySim)
}
\dontrun{
showCache(mySim)
}
}
\seealso{
\code{\link[archivist]{cache}}.

\code{\link[archivist]{splitTagsLocal}}.
}
\author{
Eliot McIntire
}
